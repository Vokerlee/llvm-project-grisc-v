#include "MCTargetDesc/GRISCVMCTargetDesc.h"
#include "GRISCVTargetMachine.h"
#include "GRISCVMatInt.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "griscv-isel"

namespace llvm {

class GRISCVDAGToDAGISel : public SelectionDAGISel {
  static char ID;
  const GRISCVSubtarget *Subtarget = nullptr;

public:
  GRISCVDAGToDAGISel(GRISCVTargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISel(ID, TM, OptLevel) {}

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<GRISCVSubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  bool SelectAddrFI(SDValue Addr, SDValue &Base);
  bool SelectBaseAddr(SDValue Addr, SDValue &Base);

  void Select(SDNode *N) override;

  StringRef getPassName() const override {
    return "griscv DAG->DAG Pattern Instruction Selection";
  }

// Include the pieces autogenerated from the target description.
#include "GRISCVGenDAGISel.inc"
};

/// This pass converts a legalized DAG into a griscv-specific DAG, ready for
/// instruction scheduling.
FunctionPass *createGRISCVISelDag(GRISCVTargetMachine &TM,
                                  CodeGenOptLevel OptLevel) {
  return new GRISCVDAGToDAGISel(TM, OptLevel);
}

} // namespace llvm

bool GRISCVDAGToDAGISel::SelectAddrFI(SDValue Addr, SDValue &Base) {
  if (auto *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
    return true;
  }
  return false;
}

bool GRISCVDAGToDAGISel::SelectBaseAddr(SDValue Addr, SDValue &Base) {
  if (auto *FIN = dyn_cast<FrameIndexSDNode>(Addr))
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
  else
    Base = Addr;
  return true;
}

static SDNode *SelectImm(SelectionDAG *CurDAG, const SDLoc &DL, const MVT VT,
                         int64_t Imm, const GRISCVSubtarget &Subtarget) {
  MVT XLenVT = Subtarget.getXLenVT();
  GRISCVMatInt::InstSeq Seq =
      GRISCVMatInt::generateInstSeq(Imm, Subtarget.getFeatureBits());

  SDNode *Result = nullptr;
  SDValue SrcReg = CurDAG->getRegister(griscv::X0, XLenVT);

  for (GRISCVMatInt::Inst &Inst : Seq) {
    SDValue SDImm = CurDAG->getTargetConstant(Inst.Imm, DL, XLenVT);
    if (Inst.Opc == griscv::LUI)
      Result = CurDAG->getMachineNode(griscv::LUI, DL, XLenVT, SDImm);
    else
      Result = CurDAG->getMachineNode(Inst.Opc, DL, XLenVT, SrcReg, SDImm);

    // Only the first instruction has X0 as its source.
    SrcReg = SDValue(Result, 0);
  }

  return Result;
}

void GRISCVDAGToDAGISel::Select(SDNode *Node) {
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  unsigned Opcode = Node->getOpcode();
  SDLoc DL(Node);
  MVT XLenVT = Subtarget->getXLenVT();
  MVT VT = Node->getSimpleValueType(0);

  switch (Opcode) {
  case ISD::Constant: {
    auto *ConstNode = cast<ConstantSDNode>(Node);
    if (VT == XLenVT && ConstNode->isZero()) {
      SDValue New =
          CurDAG->getCopyFromReg(CurDAG->getEntryNode(), DL, griscv::X0, XLenVT);
      ReplaceNode(Node, New.getNode());
      return;
    }

    int64_t Imm = ConstNode->getSExtValue();
    ReplaceNode(Node, SelectImm(CurDAG, DL, VT, Imm, *Subtarget));
    return;
  }
  case ISD::FrameIndex: {
    SDValue Imm = CurDAG->getTargetConstant(0, DL, MVT::i64);
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
    ReplaceNode(Node, CurDAG->getMachineNode(griscv::ADDI, DL, VT, TFI, Imm));
    return;
  }

  default:
    dbgs() << "OPCODE: " << Opcode << '\n';
    Node->dump();
  }

  SelectCode(Node);
}

char GRISCVDAGToDAGISel::ID = 0;
